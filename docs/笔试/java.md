# java面试笔记

1. 当一个线程抛出 OOM 异常后，它所占据的内存资源会被快速的释放掉，从而不会影响其他线程的运行。
另外当一个线程 OutOfMemoryError 后，如果这个 OutOfMemoryError 被捕获，那么 catch 之后吞掉的
话程序还能试着继续运行。发生 OutOfMemoryError 之后，只是当前这个线程申请更多的内存的时候不被JVM允许，
所以会抛出 OutOfMemoryError 异常。当抛出 OutOfMemoryError 异常后，当前这个线程会被退出，它所占的内存会被 JVM 清理掉。

2. finally块代码不一定会执行，若是在try模块中，程序被终止System.exit(0)，finally则不一定执行。

3. System.gc();只是提醒虚拟机要进行垃圾回收了，并不是强制。

4. 创建泛型对象的时候，一定要指出类型变量T的具体类型。争取让编译器检查出错误，而不是留给JVM运行的时候抛出类不匹配的异常。 
 2、JVM如何理解泛型概念 —— 类型擦除。事实上，JVM并不知道泛型，所有的泛型在编译阶段就已经被处理成了普通类和方法。 
 处理方法很简单，我们叫做类型变量T的擦除(erased) 。 总结：泛型代码与JVM ① 虚拟机中没有泛型，只有普通类和方法。 
 ② 在编译阶段，所有泛型类的类型参数都会被Object或者它们的限定边界来替换。(类型擦除) ③ 在继承泛型类型的时候，桥方法的合成是为了避免类型变量擦除所带来的多态灾难。 无论我们如何定义一个泛型类型，相应的都会有一个原始类型被自动提供。原始类型的名字就是擦除类型参数的泛型类型的名字。
 
5. 三元操作符类型的转换规则：
   1.若两个操作数不可转换，则不做转换，返回值为Object类型  
   2.若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。  
   3.若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。  
   4.若两个操作数都是直接量数字，则返回值类型为范围较大者  
   
6. 如果线上某台虚机CPU Load过高，该如何快速排查原因？只介绍思路和涉及的Linux命令即可   
  造成cpu load过高的原因： Full gc次数的增大、代码中存在Bug（例如死循环、正则的不恰当使用等）都有可能造成cpu load 增高。
  1.jps -v：查看java进程号
  2.top -Hp [java进程号]：查看当前进程下最耗费CPU的线程
  3.printf "%x\n" [步骤2中的线程号]：得到线程的16进制表示
  4.jstack [java进程号] | grep -A100 [步骤3的结果]：查看线程堆栈，定位代码行
 
7. [关于接口和抽象类](src/knowledge/AbstractImpl.java)

8. 请你解释为什么重写equals还要重写hashcode？

   HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素 是否相等。重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。

9.  Object o = new Object()在内存中 占多少字节 16